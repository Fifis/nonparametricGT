% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothing-functions.R
\name{bw.CV}
\alias{bw.CV}
\title{Bandwidth Selectors for Kernel Density Estimation}
\usage{
bw.CV(
  x,
  y = NULL,
  kernel = "gaussian",
  start.bw = NULL,
  same = FALSE,
  CV = c("DCV", "LSCV"),
  opt.fun = c("nlm", "optim", "nlminb", "optimise"),
  ret.fun = NULL,
  par.name.in.opt = NULL,
  fun.name.in.opt = NULL,
  ...
)
}
\arguments{
\item{x}{A numeric vector or numeric matrix.}

\item{y}{A numeric vector of responses (dependent variable) if \code{CV == "LSCV"}.}

\item{kernel}{Which kernel to use? Passed to \code{kernelWeights}.}

\item{start.bw}{A starting value for the optimiser. If \code{NULL}, then Silvermanâ€™s rule of thumb is applied to each column of \code{x} via \code{bw.rot}.}

\item{same}{Logical: use a unique single bandwidth for all columns of \code{x}? Best used if the variability of data across the columns of \code{x} is of the same order of magnitude.}

\item{CV}{Density or least-squares cross-validation?}

\item{opt.fun}{Optimiser to be used. If 'optimise', then \code{...} must contain an interval.}

\item{ret.fun}{If a custom minimiser is used and returns a list, this function should extract the argmin.}

\item{par.name.in.opt}{If a custom minimiser is used and returns a list, this is the name of the argument corresponding to the initial parameter value.}

\item{fun.name.in.opt}{If a custom minimiser is used and returns a list, this is the name of the argument corresponding to the objective function to be minimised.}

\item{...}{Passed to \code{opt.fun}.}
}
\value{
An estimate of the optimal bandwidth.
}
\description{
Bandwidth Selectors for Kernel Density Estimation
}
\examples{
set.seed(1)
x <- rnorm(100)
y <- x^2 + rnorm(100)
plot(x, y, bty = "n")
bw.grid <- seq(0.12, 1, length.out = 101)
DCV.vals1 <- DCV(x = x, bw = bw.grid)
DCV.vals2 <- DCV(x = x, bw = bw.grid, kernel = "epanechnikov")
DCV.vals3 <- LSCV(x = x, y = y, bw = bw.grid, kernel = "epanechnikov")
DCV.vals1 <- (DCV.vals1 - min(DCV.vals1)) / diff(range(DCV.vals1))
DCV.vals2 <- (DCV.vals2 - min(DCV.vals2)) / diff(range(DCV.vals2))
DCV.vals3 <- (DCV.vals3 - min(DCV.vals3)) / diff(range(DCV.vals3))
plot(bw.grid, DCV.vals1 - min(DCV.vals1), type = "l", bty = "n",
  xlab = "Bandwidth", ylab = "CV criterion")
lines(bw.grid, DCV.vals2, lty = 2)
lines(bw.grid, DCV.vals3, lwd = 2, col = "red")
bw.CV(x)
bw.CV(x, kernel = "epanechnikov", start.bw = 0.5, opt.fun = "optim", method = "BFGS")
bw.CV(x, y = y, kernel = "epanechnikov", CV = "LSCV")
}
