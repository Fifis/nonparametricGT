% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothing-functions.R
\name{kernelFun}
\alias{kernelFun}
\title{Basic univatiate kernel functions}
\usage{
kernelFun(
  x,
  kernel = c("gaussian", "uniform", "triangular", "epanechnikov", "quartic"),
  rescale = TRUE,
  convolution = FALSE
)
}
\arguments{
\item{x}{A numeric vector of values at which to compute the kernel function.}

\item{kernel}{Kernel type: uniform, Epanechnikov, triangular, quartic, or Gaussian.}

\item{rescale}{Logical: rescale to unit variance? If \code{TRUE}, ensures
\eqn{\int_{-\infty}^{+\infty} x^2 k(x) = \sigma^2_k = 1}{\int_{-Inf}^{+Inf} x^2 k(x) = \sigma^2_k = 1}.}

\item{convolution}{Logical: return the convolution kernel? (Useful for density cross-validation.)}
}
\value{
A numeric vector of the same length as input.
}
\description{
Computes 5 most popular kernel functions with the potential of returning an analytical convolution kernel for density cross-validation.
}
\examples{
all.kernels <- c("uniform", "triangular", "epanechnikov", "quartic", "gaussian")
my.colours <- c("#000000CC", "#0000CCCC", "#CC0000CC", "#00AA00CC", "#BB8800CC")
curve(kernelFun(x, kernel = "uniform", rescale = FALSE), -2, 2, n = 501, ylim = c(0, 1.1),
col = my.colours[1], lwd = 2, ylab = "Kernel", main = "Kernels used in smoothing", bty = "n")
for (i in 2:5) curve(kernelFun(x, kernel = all.kernels[i], rescale = FALSE), -2, 2,
  add = TRUE, col = my.colours[i], lwd = 2)
legend("topright", legend = all.kernels, lwd = 2, col = my.colours, bty = "n")

# All kernels integrate to one
for (k in all.kernels) print(integrate(function(x) kernelFun(x, kernel = k, rescale = FALSE),
  lower = -Inf, upper = Inf, rel.tol = 1e-8))
for (k in all.kernels) print(integrate(function(x) kernelFun(x, kernel = k, rescale = TRUE),
  lower = -Inf, upper = Inf, rel.tol = 1e-8))
# Without scaling, the variance is different for different kernels
for (k in all.kernels) print(integrate(function(x) x^2*kernelFun(x, kernel=k, rescale=FALSE),
  lower = -Inf, upper = Inf, rel.tol = 1e-8))
for (k in all.kernels) print(integrate(function(x) x^2*kernelFun(x, kernel=k, rescale=TRUE),
  lower = -Inf, upper = Inf, rel.tol = 1e-8))
}
